---
title: 如何解决消息重复，保证消息顺序问题
date: 2020-11-15 22:11:12
tags:
- Kafka
- 消息队列
---

## 背景

让我们思考下下面两个场景

（1）收银系统，确认收款成功，通过MQ通知给物流系统发货。

（2）消费积分，用户每消费一笔给用户增加一定积分，京东豆，信用卡积分，2020年如果还没倒闭的电商平台中，可以100%的确定订单系统和积分/奖励系统不是耦合在一起的。

这些都是很典型的使用**消息队列**的场景。

那么问题来了，想象一下，积分系统收到同一个用户同一个订单两条相同的消息会怎样？积分会被加两遍吗？

## 问题分析

积分系统收到同一个用户同一个订单两条相同的消息会怎样，先不管因为什么原因消息发了两次，积分会被加两遍吗？合理的情况下，当然应该保持**幂等性**

## 解决方案
- 从上游就做消息去重处理（但是我们不能100%相信上游系统一定可靠）
- 当前消费端进行幂等设计

我可以根据用户订单号或者流水号做强幂等，每成功操作一次加积分就记录下来，即使消息重负了，我只要判断同一个订单号已经操作加分了，后续我们就不会再做任何操作了。

```java
//没收到给用户消费通知,先判断这个orderId时候已经有加过积分的历史记录，如果没有操作过，则增加。如果已经操作过，直接返回不做任何处理。
List<UserPointHistory> lists = userPointDao.queryHistory(orderId);
if(CollectionUtils.isNotEmpty(lists)){
  //1.加100分。
  userPoint.add(pointCount,orderId);
  //2.保存增加记录
  userPoint.addHistory(orderId);
}else{
  log.info("该订单已经操作过积分操作")
  return null;
}
```

> 上面的代码加积分和保存增加记录要保证事务性，否则该接口就不是幂等操作

## 怎么解决消息顺序消费问题

问题分析：

这个问题什么意思呢，比如一个消息Producer发送顺序是1 2 3，
那Consumer接收到的消息也是 1 2 3 ，想要实现消息有序就要牺牲点什么东西 ---- 性能/可靠性。


这个问题从三个角度考虑：


- Producer：让生产端同步发送消息，消息1确定发送成功后再发送消息2，不能异步，保证消息顺序入队。
- 服务端：Producer -> MQ Server -> Consumer 一对一关系，一对一服务，这肯定能保证消息是按照顺序消费的，那么问题来了：
   Producer -> MQ Server -> Consumer任意一个环节出现问题，那肯定整个链路都阻塞了。
单通道模型性能成为瓶颈。

- topic不分区：意思就是让同一个topic主题都入一个队列，在分布式环境下如果同一个topic进入多个分区，那多个分区之间肯定无法保证消息顺序了。
- Consumer：保证消费端是串行消费，禁止使用多线程。

但是这些方法都会牺牲掉系统的性能和稳定性，顺序性问题非要使用MQ来做，那也没有太好的办法了。


### 如何做到topic不分区

**RocketMQ**： RocketMQ提供了MessageQueueSelector队列选择机制，我们可以把 Topic 用Hash取模法，相同Topic的Hash值肯定是一样的，让同一个 Topic 同一个队列中，再使用同步发送，这样就能保证消息在一个分区有序了。

**Kafka**： Kafka可以把 max.in.flight.requests.per.connection 参数设置成1，这样就可以保证同一个topic在同一个分区内了。


>Topic就是一个字符串，给同一类消息取个名字加以区分，如：topic.com.xxx.order.orderId，大多数用户都可以通过message key来定义，因为同一个key的message可以保证只发送到同一个partition，比如说key是user id，table row id等等。

## 总结
关于消息重复和消息顺序消费问题解决思路比较简单，都是一些小技巧。

如果用两句话概括：

- 如何保证消息重复问题：消费端接口幂等。
- 如何保证消息顺序消费问题：让同一个消息不分区，且单线程。

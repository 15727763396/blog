---
title: 比特币如何挖矿-工作量证明
date: 2019-06-16 19:56:24
tags: 
    - 区块链
---
<meta name="referrer" content="no-referrer" />

## 前言

在 区块链记账原理 一篇，我们了解到**记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程**。

我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？  
在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”。  
本文将详细讨论这个过程。

## 记账工作

```json
认真工作是会有奖励的！
```

由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币，因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：

- 一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功
- 通过解决密码学难题（即工作量证明）竞争获得唯一记账权
- 其他节点复制记账结果

不过在进行工作量证明之前，记账节点会做进行如下准备工作：

- 收集广播中还没有被记录账本的原始交易信息
- 检查每个交易信息中付款地址有没有足够的余额
- 验证交易是否有正确的签名
- 把验证通过的交易信息进行打包记录
- 添加一个奖励交易：给自己的地址增加 12.5 比特币

如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。

## 工作量证明

通过上篇区块链记账原理我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。  
如果仅仅是这样，显然每个人都可以很轻松的完成记账。  
为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。

用伪代码表示一下：

```json
Hash(上一个Hash值，交易记录集) = 456635BCD
Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD
```

我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜）。  
率先找到随机数的节点就获得此次记账的唯一记账权。

## 计算量分析

我们简单分析下记账难度有多大：

Hash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算。

```json
以 n 个 0 开头就需要尝试 62 的 n 次方次运算。
```

## 验证

在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。

如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。  
网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。

假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。





